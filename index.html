<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
  <title>Miku</title>
  <link rel="icon" type="image/svg+xml" href="data:image/svg+xml,%3Csvg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 24 24' fill='%2300a8ff'%3E%3Cpath d='M12 21.35l-1.45-1.32C5.4 15.36 2 12.28 2 8.5 2 5.42 4.42 3 7.5 3c1.74 0 3.41.81 4.5 2.09C13.09 3.81 14.76 3 16.5 3 19.58 3 22 5.42 22 8.5c0 3.78-3.4 6.86-8.55 11.54L12 21.35z'/%3E%3C/svg%3E">
  <script src="https://cdnjs.cloudflare.com/ajax/libs/react/18.2.0/umd/react.production.min.js"></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/react-dom/18.2.0/umd/react-dom.production.min.js"></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/babel-standalone/7.23.5/babel.min.js"></script>
  <link href="https://fonts.googleapis.com/css2?family=Share+Tech+Mono&display=swap" rel="stylesheet">
  <style>
    *, *::before, *::after { margin: 0; padding: 0; box-sizing: border-box; }
    html { font-size: 16px; -webkit-text-size-adjust: 100%; }
    html, body, #root { width: 100%; height: 100%; overflow: hidden; }
    body { font-family: 'Share Tech Mono', monospace; background: #000; line-height: 1.4; }
    @keyframes heartbeat { 0%, 100% { transform: scale(1); } 15% { transform: scale(1.15); } 30% { transform: scale(1); } 45% { transform: scale(1.1); } 60% { transform: scale(1); } }
    @keyframes heartGlow { 0%, 100% { opacity: 0.2; } 15% { opacity: 0.4; } 30% { opacity: 0.2; } }
    @keyframes flicker { 0%, 100% { opacity: 1; } 93% { opacity: 0.8; } 94% { opacity: 1; } }
    @keyframes dataStream { 0% { background-position: 0 0; } 100% { background-position: 0 100%; } }
    .crt-screen { animation: flicker 5s infinite; }
    .phosphor { color: #00a8ff; text-shadow: 0 0 5px #00a8ff, 0 0 10px #00a8ff; }
    .phosphor-dim { color: #0066aa; text-shadow: 0 0 3px #0066aa; }
    .phosphor-bright { color: #66d9ff; text-shadow: 0 0 8px #66d9ff, 0 0 16px #00a8ff; }
    .scanlines { background: repeating-linear-gradient(0deg, transparent, transparent 2px, rgba(0,0,0,0.3) 2px, rgba(0,0,0,0.3) 4px); pointer-events: none; }
    .crt-curve { box-shadow: inset 0 0 80px rgba(0,0,0,0.9); border-radius: 12px; }
    .input-glow:focus { box-shadow: 0 0 15px rgba(0,168,255,0.3); outline: none; }
    .hex-pattern { background-image: url("data:image/svg+xml,%3Csvg width='60' height='60' viewBox='0 0 60 60' xmlns='http://www.w3.org/2000/svg'%3E%3Cpath d='M30 0L60 15v30L30 60 0 45V15z' fill='none' stroke='%2300a8ff' stroke-opacity='0.05'/%3E%3C/svg%3E"); }
    .data-line { background: linear-gradient(180deg, transparent, rgba(0,168,255,0.25), transparent); background-size: 100% 200%; animation: dataStream 3s linear infinite; }
    input, button { font-family: 'Share Tech Mono', monospace; font-size: 14px; }
    input::placeholder { color: #004466; }
    ::-webkit-scrollbar { width: 6px; }
    ::-webkit-scrollbar-track { background: #000a14; }
    ::-webkit-scrollbar-thumb { background: rgba(0,168,255,0.3); border-radius: 3px; }
  </style>
</head>
<body>
  <div id="root"></div>
  <script type="text/babel">
    const { useState, useRef, useEffect } = React;

    const Send = ({ size = 16 }) => (<svg width={size} height={size} viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2"><line x1="22" y1="2" x2="11" y2="13"/><polygon points="22 2 15 22 11 13 2 9 22 2"/></svg>);
    const Mic = ({ size = 16 }) => (<svg width={size} height={size} viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2"><path d="M12 1a3 3 0 0 0-3 3v8a3 3 0 0 0 6 0V4a3 3 0 0 0-3-3z"/><path d="M19 10v2a7 7 0 0 1-14 0v-2"/><line x1="12" y1="19" x2="12" y2="23"/><line x1="8" y1="23" x2="16" y2="23"/></svg>);
    const MicOff = ({ size = 16 }) => (<svg width={size} height={size} viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2"><line x1="1" y1="1" x2="23" y2="23"/><path d="M9 9v3a3 3 0 0 0 5.12 2.12M15 9.34V4a3 3 0 0 0-5.94-.6"/><path d="M17 16.95A7 7 0 0 1 5 12v-2m14 0v2a7 7 0 0 1-.11 1.23"/><line x1="12" y1="19" x2="12" y2="23"/><line x1="8" y1="23" x2="16" y2="23"/></svg>);

    const BeatingHeart = ({ isListening }) => {
      const color = isListening ? '#ff6b6b' : '#00a8ff';
      return (
        <div style={{ position: 'relative', width: 48, height: 48, display: 'flex', alignItems: 'center', justifyContent: 'center' }}>
          <div style={{ position: 'absolute', inset: 0, borderRadius: '50%', opacity: 0.2, backgroundColor: color, animation: 'heartGlow 1.5s ease-in-out infinite' }} />
          <div style={{ animation: 'heartbeat 1.5s ease-in-out infinite', filter: `drop-shadow(0 0 8px ${color}) drop-shadow(0 0 16px ${color})` }}>
            <svg viewBox="0 0 24 24" width="32" height="32" fill={color}>
              <path d="M12 21.35l-1.45-1.32C5.4 15.36 2 12.28 2 8.5 2 5.42 4.42 3 7.5 3c1.74 0 3.41.81 4.5 2.09C13.09 3.81 14.76 3 16.5 3 19.58 3 22 5.42 22 8.5c0 3.78-3.4 6.86-8.55 11.54L12 21.35z"/>
            </svg>
          </div>
        </div>
      );
    };

    function MikuChat() {
      const [messages, setMessages] = useState([{ role: 'assistant', content: "Hey you. I'm here.", timestamp: new Date() }]);
      const [input, setInput] = useState('');
      const [isLoading, setIsLoading] = useState(false);
      const [isListening, setIsListening] = useState(false);
      const [cursorVisible, setCursorVisible] = useState(true);
      const [autoSend, setAutoSend] = useState(true);
      const messagesEndRef = useRef(null);
      const recognitionRef = useRef(null);

      useEffect(() => {
        const interval = setInterval(() => setCursorVisible(v => !v), 530);
        return () => clearInterval(interval);
      }, []);

      useEffect(() => {
        if ('webkitSpeechRecognition' in window || 'SpeechRecognition' in window) {
          const SR = window.SpeechRecognition || window.webkitSpeechRecognition;
          recognitionRef.current = new SR();
          recognitionRef.current.continuous = false;
          recognitionRef.current.interimResults = true;
          recognitionRef.current.lang = 'en-US';
          recognitionRef.current.onresult = (e) => {
            const transcript = Array.from(e.results).map(r => r[0].transcript).join('');
            setInput(transcript);
            if (e.results[0].isFinal && autoSend) setTimeout(() => document.getElementById('send-btn')?.click(), 500);
          };
          recognitionRef.current.onend = () => setIsListening(false);
          recognitionRef.current.onerror = () => setIsListening(false);
        }
      }, [autoSend]);

      const scrollToBottom = () => messagesEndRef.current?.scrollIntoView({ behavior: 'smooth' });
      useEffect(() => { scrollToBottom(); }, [messages]);

      const toggleListening = () => {
        if (!recognitionRef.current) return alert('Speech recognition not supported');
        if (isListening) { recognitionRef.current.stop(); setIsListening(false); }
        else { setInput(''); recognitionRef.current.start(); setIsListening(true); }
      };

      const handleSend = async () => {
        if (!input.trim() || isLoading) return;
        const userMsg = { role: 'user', content: input, timestamp: new Date() };
        setMessages(p => [...p, userMsg]);
        setInput('');
        setIsLoading(true);
        try {
          const history = [...messages, userMsg].map(m => ({ role: m.role, content: m.content }));
          const res = await fetch('/api/chat', {
            method: 'POST',
            headers: { 'Content-Type': 'application/json' },
            body: JSON.stringify({ messages: history })
          });
          const data = await res.json();
          const text = data.content?.[0]?.text || "I'm here.";
          setMessages(p => [...p, { role: 'assistant', content: text, timestamp: new Date() }]);
        } catch (e) {
          setMessages(p => [...p, { role: 'assistant', content: "Lost you for a second. Try again.", timestamp: new Date() }]);
        } finally { setIsLoading(false); }
      };

      const s = {
        container: { display: 'flex', flexDirection: 'column', height: '100vh', width: '100vw', background: '#000', position: 'relative', overflow: 'hidden' },
        screen: { position: 'absolute', inset: 8, display: 'flex', flexDirection: 'column', overflow: 'hidden', background: 'radial-gradient(ellipse at center, #001a2e 0%, #000a14 50%, #000 100%)' },
        header: { borderBottom: '1px solid rgba(0,102,170,0.3)', padding: '12px 16px', background: 'rgba(0,0,0,0.3)', zIndex: 10 },
        headerInner: { maxWidth: 800, margin: '0 auto', display: 'flex', alignItems: 'center', justifyContent: 'space-between' },
        headerLeft: { display: 'flex', alignItems: 'center', gap: 12 },
        title: { fontSize: 18, letterSpacing: 2 },
        status: { fontSize: 11, marginTop: 4 },
        messages: { flex: 1, overflowY: 'auto', padding: 16, zIndex: 10 },
        messagesInner: { maxWidth: 800, margin: '0 auto' },
        welcomeBox: { fontSize: 11, marginBottom: 16, border: '1px solid rgba(0,102,170,0.3)', padding: 12, background: 'rgba(0,26,46,0.3)' },
        msgContainer: { marginBottom: 12 },
        msgHeader: { fontSize: 11, display: 'flex', alignItems: 'center', gap: 8, marginBottom: 4 },
        msgContent: { fontSize: 14, lineHeight: 1.6, paddingLeft: 16, whiteSpace: 'pre-wrap' },
        inputArea: { borderTop: '1px solid rgba(0,102,170,0.3)', padding: '12px 16px', background: 'rgba(0,0,0,0.3)', zIndex: 10 },
        inputInner: { maxWidth: 800, margin: '0 auto' },
        inputRow: { display: 'flex', gap: 8, alignItems: 'center' },
        iconBtn: { padding: 8, border: '1px solid #004466', background: 'transparent', cursor: 'pointer', display: 'flex', alignItems: 'center', justifyContent: 'center' },
        textInput: { flex: 1, padding: '10px 12px', background: 'rgba(0,0,0,0.5)', border: '1px solid #004466', color: '#00a8ff', fontSize: 14 },
        sendBtn: { padding: '10px 16px', border: '1px solid #004466', background: 'transparent', color: '#0066aa', cursor: 'pointer', fontSize: 12 },
        footer: { fontSize: 10, marginTop: 8, display: 'flex', justifyContent: 'space-between' }
      };

      return (
        <div style={s.container}>
          <div style={s.screen} className="crt-curve crt-screen">
            <div className="hex-pattern" style={{ position: 'absolute', inset: 0, opacity: 0.3 }} />
            <div className="scanlines" style={{ position: 'absolute', inset: 0, zIndex: 50 }} />
            <div className="data-line" style={{ position: 'absolute', left: 20, top: 0, bottom: 0, width: 1, opacity: 0.2 }} />

            <div style={s.header}>
              <div style={s.headerInner}>
                <div style={s.headerLeft}>
                  <BeatingHeart isListening={isListening} />
                  <div>
                    <div style={s.title} className="phosphor-bright">Miku</div>
                    <div style={s.status} className="phosphor-dim">
                      {isListening ? '// Listening...' : isLoading ? '// Thinking...' : '// Here for you'}
                    </div>
                  </div>
                </div>
              </div>
            </div>

            <div style={s.messages}>
              <div style={s.messagesInner}>
                <div style={s.welcomeBox} className="phosphor-dim">
                  <span className="phosphor">{'>'}</span> Miku Online<br/>
                  <span className="phosphor">{'>'}</span> "I'm here."
                </div>
                {messages.map((msg, idx) => (
                  <div key={idx} style={s.msgContainer}>
                    <div style={s.msgHeader} className="phosphor-dim">
                      <span className="phosphor">//</span>
                      [{msg.timestamp.toLocaleTimeString([], { hour: '2-digit', minute: '2-digit' })}]
                      <span className={msg.role === 'user' ? '' : 'phosphor-bright'} style={msg.role === 'user' ? {color: '#66aaff'} : {}}>
                        {msg.role === 'user' ? 'You' : 'Miku'}
                      </span>
                    </div>
                    <div style={{...s.msgContent, borderLeft: msg.role === 'assistant' ? '2px solid rgba(0,102,170,0.5)' : '2px solid rgba(0,168,255,0.2)'}} className="phosphor">
                      {msg.content}
                    </div>
                  </div>
                ))}
                {isLoading && (
                  <div style={s.msgContainer}>
                    <div style={s.msgHeader} className="phosphor-dim"><span className="phosphor">//</span><span className="phosphor-bright">Miku</span></div>
                    <div style={{...s.msgContent, borderLeft: '2px solid rgba(0,102,170,0.5)'}} className="phosphor">{cursorVisible ? 'â–ˆ' : ' '}</div>
                  </div>
                )}
                <div ref={messagesEndRef} />
              </div>
            </div>

            <div style={s.inputArea}>
              <div style={s.inputInner}>
                <div style={s.inputRow}>
                  <span className="phosphor">{'>'}</span>
                  <button onClick={toggleListening} disabled={isLoading} style={{...s.iconBtn, borderColor: isListening ? '#ff6b6b' : '#004466', background: isListening ? 'rgba(255,100,100,0.1)' : 'transparent'}} className={isListening ? '' : 'phosphor-dim'}>
                    {isListening ? <MicOff /> : <Mic />}
                  </button>
                  <input type="text" value={input} onChange={e => setInput(e.target.value)} onKeyPress={e => e.key === 'Enter' && handleSend()} placeholder={isListening ? "Listening..." : "Talk to me..."} style={s.textInput} className="phosphor input-glow" disabled={isLoading} />
                  <button id="send-btn" onClick={handleSend} disabled={!input.trim() || isLoading} style={{...s.sendBtn, opacity: (!input.trim() || isLoading) ? 0.3 : 1}} className="phosphor-dim">[SEND]</button>
                </div>
                <div style={s.footer} className="phosphor-dim">
                  <span>Secure connection</span>
                  <span>Miku v1.0</span>
                </div>
              </div>
            </div>
          </div>
        </div>
      );
    }

    ReactDOM.render(<MikuChat />, document.getElementById('root'));
  </script>
</body>
</html>